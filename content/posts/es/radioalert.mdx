---
title: "TranscripciÃ³n en directo de una emisora de radio con Whisper en modo Vibe Coding"
date: "2025-06-09"
summary: "PequeÃ±o experimento que captura y transcribe en tiempo real un stream de radio con Whisper, y muestra las palabras clave en una web de estilo retro."
image: "/images/radio-alert.png"
categories: ["experimentos", "codificaciÃ³n-creativa", "transcripciÃ³n", "vibecoding", "ia"]
slug: "radio-alert"
---

# El Proyecto

Este proyecto es un pequeÃ±o experimento para capturar y transcribir en tiempo real un flujo de audio de una emisora de radio (RAC1) y mostrar los fragmentos mÃ¡s relevantes mediante una interfaz web minimalista. Todo automatizado con Docker.

TambiÃ©n es una prueba personal de *vibe coding*, hecha con un objetivo claro pero sin planificaciÃ³n previaâ€”simplemente dejÃ¡ndome llevar por la intuiciÃ³n para ver hasta dÃ³nde puede acelerarse el desarrollo. Aunque el proyecto funciona, reconozco que con este proceso se pierde parte del placer de un conocimiento estructurado y de una planificaciÃ³n que harÃ­a la soluciÃ³n mÃ¡s robusta y escalable.

Este estilo rÃ¡pido e improvisado de programar tiende a omitir ciertas abstracciones y estructuras que a menudo son las que permiten una creatividad mÃ¡s profunda: aquella que emerge cuando las herramientas no solo funcionan, sino que se entienden *por quÃ©* funcionan.

## Accede a la Demo

ğŸ‘‰ PruÃ©balo: [https://eurekatop.com/radioalert](https://eurekatop.com/radioalert)  
ğŸ‘‰ Endpoint SSE: [https://eurekatop.com/radioalert/events](https://eurekatop.com/radioalert/events)

<img
  src="/images/radio-alert-content-1.png"
  alt="DescripciÃ³n de la imagen"
  style={{ alignSelf: 'center', width: '80%', maxWidth: '80%', height: 'auto', borderRadius: '12px' }}
/>

## Backend: TranscripciÃ³n AutomÃ¡tica con Whisper

La base del proyecto es un script en Python que escucha el stream como si fuera un navegador. Al principio probÃ© usar `ffmpeg` para capturar el stream, pero fallÃ³ porque la emisora tiene protecciones antibot y no aceptÃ³ la conexiÃ³n.

Como alternativa, descubrÃ­ que usando `httpx.stream()` se puede leer el flujo de audio sin problemasâ€”siempre que la peticiÃ³n parezca provenir de un navegador real. Por eso hay que aÃ±adir algunos headers...

El script estÃ¡ dividido en dos partes: una para la captura del stream y otra para la transcripciÃ³n y filtrado de palabras clave. Esta transcripciÃ³n se realiza en paralelo con la captura, por lo que no es necesario esperar a que finalice para seguir capturando.

El audio se procesa en bloques de 4 segundos y se transcribe usando el modelo optimizado *Whisper* (`int8`).

```python
model = WhisperModel("/models/whisper-small", compute_type="int8")
segments, _ = model.transcribe(BytesIO(audio_data), language="ca")
```

Una vez transcrito, se busca si aparecen palabras clave como â€œbarÃ§aâ€, â€œavuiâ€ o â€œlamine yamalâ€. Si se detectan, se genera una alerta y se escribe todo en un archivo `.log`. Por ejemplo:

ğŸ•’ [2025-06-09 14:10:23] ğŸ—£ï¸ [12] avui a catalunya hem vist que...  
ğŸš¨ ğŸ•’ [2025-06-09 14:10:23] ALERTA: Palabra clave detectada: avui

El sistema aÃ±ade una pequeÃ±a cola de audio anterior para evitar cortes entre frases, ya que el modelo necesita contexto para entender bien las primeras palabras del stream.

Todo estÃ¡ automatizado con Docker.

## Frontend: VisualizaciÃ³n en Directo

Un pequeÃ±o servidor en Node.js muestra las lÃ­neas transcritas en directo desde un archivo `.log`, enviÃ¡ndolas vÃ­a Server-Sent Events a la interfaz web de estilo â€œterminalâ€.

```js
fs.readFile(FILE_PATH, 'utf8', (err, data) => {
  const lines = data.trim().split('\n').slice(-30)
  lines.forEach(line => res.write(`data: ${line}\n\n`))
})
```

En el cliente, la conexiÃ³n permanece abierta con `EventSource()` del navegador, que recibe automÃ¡ticamente las actualizaciones en tiempo real:

```js
const eventSource = new EventSource('/events')
eventSource.onmessage = function(event) {
  console.log(event.data)
}
```

---

## ğŸ’¡ Aprendizajes

- Whisper es bastante fiable, incluso en catalÃ¡n.
- AÃ±adir una cola de audio anterior mejora la precisiÃ³n en frases cortadas.
- Con `httpx.stream` e hilos ligeros se puede capturar audio de forma estable sin saturar el proceso principal. `ffmpeg` fue descartado para evitar las protecciones antibot, simulando una conexiÃ³n de navegador real.
- Server-Sent Events es una herramienta muy simple pero efectiva para enviar datos en vivo a una web.

## Stack y TÃ©cnicas

- ğŸ Python + [faster-whisper](https://github.com/guillaumekln/faster-whisper)
- ğŸ“¡ httpx para capturar streams de audio
- ğŸ›ï¸ TranscripciÃ³n en catalÃ¡n con el modelo Whisper-small optimizado
- ğŸ³ Docker para encapsular el servicio
- ğŸŸ© Node.js + Express para exponer el archivo como feed SSE
- ğŸ¨ HTML + CSS en modo consola de terminal

---

Un experimento en vibe coding por Francesc LÃ³pez MariÃ³, 2025
