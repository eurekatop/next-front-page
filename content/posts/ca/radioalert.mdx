---
title: "TranscripciÃ³ en directe d'una emissora de rÃ dio amb Whisper en mode Vibe Coding"
date: "2025-06-09"
summary: "Petit experiment que captura i transcriu en temps real un stream de rÃ dio amb Whisper, i en mostra les paraules clau en una web estil retro."
image: "/images/radio-alert.png"
categories: ["experiments", "codificacio-creativa", "transcripcio", "vibecoding", "ia"]
slug: "radio-alert"
---


# El projecte

Aquest projecte Ã©s un petit experiment per capturar i transcriure en temps real un stream dâ€™Ã udio dâ€™una emissora de rÃ dio (RAC1) i mostrar-ne els fragments mÃ©s rellevants mitjanÃ§ant una interfÃ­cie web minimalista. Tot plegat, automatitzat amb Docker.

Ã‰s tambÃ© una prova personal de *vibe coding*, feta amb un objectiu clar perÃ² sense planificaciÃ³ prÃ¨via, simplement deixant-se portar per la intuÃ¯ciÃ³ i fins a qui punt pot accelerar el desenvolupament. Tot i que el projecte funciona, reconec que amb aquest procÃ©s sâ€™hi perd part del plaer dâ€™un coneixement estructurat i dâ€™una planificaciÃ³ que faria la soluciÃ³ mÃ©s robusta i escalable.

Amb aquesta manera de programar, rÃ pida i improvisada, es tendeixen a obviar certes abstraccions i estructures que sovint sÃ³n les que obren la porta a la creativitat mÃ©s profunda: aquella que emergeix quan les eines no nomÃ©s funcionen, sinÃ³ que s'entenen perquÃ¨ funcionen.


## Accedeix a la demo

ğŸ‘‰ Provaâ€™l: [https://eurekatop.com/radioalert](https://eurekatop.com/radioalert)  
ğŸ‘‰ Endpoint SSE: [https://eurekatop.com/radioalert/events](https://eurekatop.com/radioalert/events)


<img
  src="/images/radio-alert-content-1.png"
  alt="DescripciÃ³ de la imatge"
  style={{ alignSelf: 'center', width: '80%', maxWidth: '80%', height: 'auto', borderRadius: '12px' }}
/>


## Backend: TranscripciÃ³ AutomÃ tica amb Whisper

La base del projecte Ã©s un script en Python que escolta el stream com si fos un navegador. En un primer intent he provat d'utilitzar `ffmpeg` per capturar el stream, perÃ² ha fallat perquÃ¨ l'emissora tÃ© proteccions antibot i la connexiÃ³ no va ser acceptada. 

Com alternativa he trobat que utilitzant `httpx.stream()` es pot llegir el flux d'Ã udio sense problemes. Sempre que la peticiÃ³ sembli que Ã©s la d'un navegador real. Per aixÃ² cal afegir alguns headers...

El script s'ha separat en dos parts: una per la captura del stream i una altra per la transcripciÃ³ i filtratge de paraules clau. Aquesta transcripciÃ³ es fa en paralÂ·lel amb la captura del stream, perquÃ¨ no cal esperar a que acabi la transcripciÃ³ per poder seguir capturant.

Lâ€™Ã udio llavors es processa per blocs de 4 segons i es transcriu usant el model *Whisper* optimitzat (`int8`).

```python
model = WhisperModel("/models/whisper-small", compute_type="int8")
segments, _ = model.transcribe(BytesIO(audio_data), language="ca")
```

Un cop transcrit, es busca si apareixen paraules clau com â€œbarÃ§aâ€, â€œavuiâ€ o â€œlamine yamalâ€, i si Ã©s el cas, es genera una alerta i s'escriu tot a un fitxer `.log`. Per exemple:

ğŸ•’ [2025-06-09 14:10:23] ğŸ—£ï¸ [12] avui a catalunya hem vist que...  
ğŸš¨ ğŸ•’ [2025-06-09 14:10:23] ALERTA: Paraula clau detectada: avui

El sistema afegeix una petita cua de lâ€™Ã udio anterior per evitar talls entre frases perquÃ¨ el model necessita context per entendre bÃ© les primeres paraules del stream. 

Tot plegat, automatitzat amb Docker.

## Frontend: VisualitzaciÃ³ en Directe

Un petit servidor en Node.js mostra les lÃ­nies transcrites en directe des dâ€™un fitxer `.log`, enviant-les via Server-Sent Events a la interfÃ­cie web tipus â€œconsola de terminalâ€.

```js
fs.readFile(FILE_PATH, 'utf8', (err, data) => {
  const lines = data.trim().split('\n').slice(-30)
  lines.forEach(line => res.write(`data: ${line}\n\n`))
})
```
Al client, la connexiÃ³ es mantÃ© oberta amb EventSource() del navegador, que rep automÃ ticament les actualitzacions en temps real:

```js
const eventSource = new EventSource('/events')
eventSource.onmessage = function(event) {
  console.log(event.data)
}
```

---

## ğŸ’¡ Aprenentatges

- Whisper Ã©s forÃ§a fiable, fins i tot en catalÃ .
- Afegir una cua dâ€™Ã udio anterior millora la precisiÃ³ en frases tallades.
- Amb `httpx.stream` i fils lleugers es pot capturar Ã udio de manera estable sense saturar el procÃ©s principal. En un primer intent sâ€™havia provat dâ€™utilitzar `ffmpeg`, perÃ² sâ€™ha descartat perquÃ¨ la idea era evitar les proteccions antibot de lâ€™emissora simulant una connexiÃ³ de navegador real.
- Server-Sent Events Ã©s una eina molt simple perÃ² efectiva per enviar dades en viu a una web.

## Stack i tÃ¨cniques

- ğŸ Python + [faster-whisper](https://github.com/guillaumekln/faster-whisper)
- ğŸ“¡ httpx per capturar streams dâ€™Ã udio
- ğŸ›ï¸ TranscripciÃ³ en catalÃ  amb el model Whisper-small optimitzat
- ğŸ³ Docker per encapsular el servei
- ğŸŸ© Node.js + Express per exposar el fitxer com a feed SSE
- ğŸ¨ HTML + CSS en mode consola de terminal

---

Un experiment en vibe coding per Francesc LÃ³pez MariÃ³, 2025

